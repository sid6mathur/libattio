/*
Attio API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
Contact: support@attio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package libattio

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// CallRecordingsAPIService CallRecordingsAPI service
type CallRecordingsAPIService service

type ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest struct {
	ctx             context.Context
	ApiService      *CallRecordingsAPIService
	meetingId       string
	callRecordingId string
}

func (r ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteExecute(r)
}

/*
V2MeetingsMeetingIdCallRecordingsCallRecordingIdDelete Delete call recording

Deletes the specified call recording. This will remove the call recording and all associated data.

This endpoint is in alpha and may be subject to breaking changes as we gather feedback.

Required scopes: `meeting:read`, `call_recording:read-write`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingId
	@param callRecordingId
	@return ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest
*/
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsCallRecordingIdDelete(ctx context.Context, meetingId string, callRecordingId string) ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest {
	return ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest{
		ApiService:      a,
		ctx:             ctx,
		meetingId:       meetingId,
		callRecordingId: callRecordingId,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteExecute(r ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdDeleteRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallRecordingsAPIService.V2MeetingsMeetingIdCallRecordingsCallRecordingIdDelete")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}/call_recordings/{call_recording_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_recording_id"+"}", url.PathEscape(parameterValueToString(r.callRecordingId, "callRecordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2MeetingsMeetingIdCallRecordingsCallRecordingIdDelete404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest struct {
	ctx             context.Context
	ApiService      *CallRecordingsAPIService
	meetingId       string
	callRecordingId string
}

func (r ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest) Execute() (*V2MeetingsMeetingIdCallRecordingsPost200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdCallRecordingsCallRecordingIdGetExecute(r)
}

/*
V2MeetingsMeetingIdCallRecordingsCallRecordingIdGet Get call recording

Get a single call recording by ID.

This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.

Required scopes: `meeting:read`, `call_recording:read`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingId
	@param callRecordingId
	@return ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest
*/
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsCallRecordingIdGet(ctx context.Context, meetingId string, callRecordingId string) ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest {
	return ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest{
		ApiService:      a,
		ctx:             ctx,
		meetingId:       meetingId,
		callRecordingId: callRecordingId,
	}
}

// Execute executes the request
//
//	@return V2MeetingsMeetingIdCallRecordingsPost200Response
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsCallRecordingIdGetExecute(r ApiV2MeetingsMeetingIdCallRecordingsCallRecordingIdGetRequest) (*V2MeetingsMeetingIdCallRecordingsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsMeetingIdCallRecordingsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallRecordingsAPIService.V2MeetingsMeetingIdCallRecordingsCallRecordingIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}/call_recordings/{call_recording_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"call_recording_id"+"}", url.PathEscape(parameterValueToString(r.callRecordingId, "callRecordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2MeetingsMeetingIdCallRecordingsCallRecordingIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsMeetingIdCallRecordingsGetRequest struct {
	ctx        context.Context
	ApiService *CallRecordingsAPIService
	meetingId  string
	limit      *int32
	cursor     *string
}

func (r ApiV2MeetingsMeetingIdCallRecordingsGetRequest) Limit(limit int32) ApiV2MeetingsMeetingIdCallRecordingsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MeetingsMeetingIdCallRecordingsGetRequest) Cursor(cursor string) ApiV2MeetingsMeetingIdCallRecordingsGetRequest {
	r.cursor = &cursor
	return r
}

func (r ApiV2MeetingsMeetingIdCallRecordingsGetRequest) Execute() (*V2MeetingsMeetingIdCallRecordingsGet200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdCallRecordingsGetExecute(r)
}

/*
V2MeetingsMeetingIdCallRecordingsGet List call recordings

List all call recordings for a meeting.

This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.

Required scopes: `meeting:read`, `call_recording:read`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingId
	@return ApiV2MeetingsMeetingIdCallRecordingsGetRequest
*/
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsGet(ctx context.Context, meetingId string) ApiV2MeetingsMeetingIdCallRecordingsGetRequest {
	return ApiV2MeetingsMeetingIdCallRecordingsGetRequest{
		ApiService: a,
		ctx:        ctx,
		meetingId:  meetingId,
	}
}

// Execute executes the request
//
//	@return V2MeetingsMeetingIdCallRecordingsGet200Response
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsGetExecute(r ApiV2MeetingsMeetingIdCallRecordingsGetRequest) (*V2MeetingsMeetingIdCallRecordingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsMeetingIdCallRecordingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallRecordingsAPIService.V2MeetingsMeetingIdCallRecordingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}/call_recordings"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsMeetingIdCallRecordingsPostRequest struct {
	ctx                                          context.Context
	ApiService                                   *CallRecordingsAPIService
	meetingId                                    string
	v2MeetingsMeetingIdCallRecordingsPostRequest *V2MeetingsMeetingIdCallRecordingsPostRequest
}

func (r ApiV2MeetingsMeetingIdCallRecordingsPostRequest) V2MeetingsMeetingIdCallRecordingsPostRequest(v2MeetingsMeetingIdCallRecordingsPostRequest V2MeetingsMeetingIdCallRecordingsPostRequest) ApiV2MeetingsMeetingIdCallRecordingsPostRequest {
	r.v2MeetingsMeetingIdCallRecordingsPostRequest = &v2MeetingsMeetingIdCallRecordingsPostRequest
	return r
}

func (r ApiV2MeetingsMeetingIdCallRecordingsPostRequest) Execute() (*V2MeetingsMeetingIdCallRecordingsPost200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdCallRecordingsPostExecute(r)
}

/*
V2MeetingsMeetingIdCallRecordingsPost Create call recording

Create a call recording for a meeting. This endpoint is rate limited to 1 request per second.

This endpoint is in alpha and may be subject to breaking changes as we gather feedback.

Required scopes: `meeting:read`, `call_recording:read-write`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingId
	@return ApiV2MeetingsMeetingIdCallRecordingsPostRequest
*/
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsPost(ctx context.Context, meetingId string) ApiV2MeetingsMeetingIdCallRecordingsPostRequest {
	return ApiV2MeetingsMeetingIdCallRecordingsPostRequest{
		ApiService: a,
		ctx:        ctx,
		meetingId:  meetingId,
	}
}

// Execute executes the request
//
//	@return V2MeetingsMeetingIdCallRecordingsPost200Response
func (a *CallRecordingsAPIService) V2MeetingsMeetingIdCallRecordingsPostExecute(r ApiV2MeetingsMeetingIdCallRecordingsPostRequest) (*V2MeetingsMeetingIdCallRecordingsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsMeetingIdCallRecordingsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "CallRecordingsAPIService.V2MeetingsMeetingIdCallRecordingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}/call_recordings"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2MeetingsMeetingIdCallRecordingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MeetingsMeetingIdCallRecordingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2MeetingsMeetingIdCallRecordingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2MeetingsMeetingIdCallRecordingsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v V2MeetingsMeetingIdCallRecordingsPost403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2MeetingsMeetingIdCallRecordingsPost404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
