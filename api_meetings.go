/*
Attio API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 2.0.0
Contact: support@attio.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package libattio

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

// MeetingsAPIService MeetingsAPI service
type MeetingsAPIService service

type ApiV2MeetingsGetRequest struct {
	ctx            context.Context
	ApiService     *MeetingsAPIService
	limit          *int32
	cursor         *string
	linkedObject   *string
	linkedRecordId *string
	participants   *string
	sort           *string
	endsFrom       *string
	startsBefore   *string
	timezone       *string
}

func (r ApiV2MeetingsGetRequest) Limit(limit int32) ApiV2MeetingsGetRequest {
	r.limit = &limit
	return r
}

func (r ApiV2MeetingsGetRequest) Cursor(cursor string) ApiV2MeetingsGetRequest {
	r.cursor = &cursor
	return r
}

func (r ApiV2MeetingsGetRequest) LinkedObject(linkedObject string) ApiV2MeetingsGetRequest {
	r.linkedObject = &linkedObject
	return r
}

func (r ApiV2MeetingsGetRequest) LinkedRecordId(linkedRecordId string) ApiV2MeetingsGetRequest {
	r.linkedRecordId = &linkedRecordId
	return r
}

func (r ApiV2MeetingsGetRequest) Participants(participants string) ApiV2MeetingsGetRequest {
	r.participants = &participants
	return r
}

func (r ApiV2MeetingsGetRequest) Sort(sort string) ApiV2MeetingsGetRequest {
	r.sort = &sort
	return r
}

func (r ApiV2MeetingsGetRequest) EndsFrom(endsFrom string) ApiV2MeetingsGetRequest {
	r.endsFrom = &endsFrom
	return r
}

func (r ApiV2MeetingsGetRequest) StartsBefore(startsBefore string) ApiV2MeetingsGetRequest {
	r.startsBefore = &startsBefore
	return r
}

func (r ApiV2MeetingsGetRequest) Timezone(timezone string) ApiV2MeetingsGetRequest {
	r.timezone = &timezone
	return r
}

func (r ApiV2MeetingsGetRequest) Execute() (*V2MeetingsGet200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsGetExecute(r)
}

/*
V2MeetingsGet List meetings

Lists all meetings in the workspace using a deterministic sort order.

This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.

Required scopes: `meeting:read`, `record_permission:read`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2MeetingsGetRequest
*/
func (a *MeetingsAPIService) V2MeetingsGet(ctx context.Context) ApiV2MeetingsGetRequest {
	return ApiV2MeetingsGetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V2MeetingsGet200Response
func (a *MeetingsAPIService) V2MeetingsGetExecute(r ApiV2MeetingsGetRequest) (*V2MeetingsGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeetingsAPIService.V2MeetingsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
		var defaultValue int32 = 50
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
		r.limit = &defaultValue
	}
	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.linkedObject != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linked_object", r.linkedObject, "form", "")
	}
	if r.linkedRecordId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "linked_record_id", r.linkedRecordId, "form", "")
	}
	if r.participants != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "participants", r.participants, "form", "")
	} else {
		var defaultValue string = ""
		parameterAddToHeaderOrQuery(localVarQueryParams, "participants", defaultValue, "form", "")
		r.participants = &defaultValue
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "form", "")
	} else {
		var defaultValue string = "start_asc"
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", defaultValue, "form", "")
		r.sort = &defaultValue
	}
	if r.endsFrom != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ends_from", r.endsFrom, "form", "")
	}
	if r.startsBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "starts_before", r.startsBefore, "form", "")
	}
	if r.timezone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", r.timezone, "form", "")
	} else {
		var defaultValue string = "UTC"
		parameterAddToHeaderOrQuery(localVarQueryParams, "timezone", defaultValue, "form", "")
		r.timezone = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsMeetingIdGetRequest struct {
	ctx        context.Context
	ApiService *MeetingsAPIService
	meetingId  string
}

func (r ApiV2MeetingsMeetingIdGetRequest) Execute() (*V2MeetingsPost200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsMeetingIdGetExecute(r)
}

/*
V2MeetingsMeetingIdGet Get a meeting

Get a single meeting by ID.

This endpoint is in beta. We will aim to avoid breaking changes, but small updates may be made as we roll out to more users.

Required scopes: `meeting:read`, `record_permission:read`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param meetingId
	@return ApiV2MeetingsMeetingIdGetRequest
*/
func (a *MeetingsAPIService) V2MeetingsMeetingIdGet(ctx context.Context, meetingId string) ApiV2MeetingsMeetingIdGetRequest {
	return ApiV2MeetingsMeetingIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		meetingId:  meetingId,
	}
}

// Execute executes the request
//
//	@return V2MeetingsPost200Response
func (a *MeetingsAPIService) V2MeetingsMeetingIdGetExecute(r ApiV2MeetingsMeetingIdGetRequest) (*V2MeetingsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeetingsAPIService.V2MeetingsMeetingIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings/{meeting_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"meeting_id"+"}", url.PathEscape(parameterValueToString(r.meetingId, "meetingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v V2MeetingsMeetingIdGet404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiV2MeetingsPostRequest struct {
	ctx                   context.Context
	ApiService            *MeetingsAPIService
	v2MeetingsPostRequest *V2MeetingsPostRequest
}

func (r ApiV2MeetingsPostRequest) V2MeetingsPostRequest(v2MeetingsPostRequest V2MeetingsPostRequest) ApiV2MeetingsPostRequest {
	r.v2MeetingsPostRequest = &v2MeetingsPostRequest
	return r
}

func (r ApiV2MeetingsPostRequest) Execute() (*V2MeetingsPost200Response, *http.Response, error) {
	return r.ApiService.V2MeetingsPostExecute(r)
}

/*
V2MeetingsPost Find or create a meeting

Finds an existing meeting or creates a new one if it doesn't yet exist. [Please see here](/rest-api/guides/syncing-meetings) for a full guide on syncing meetings to Attio.

This endpoint is in alpha and may be subject to breaking changes as we gather feedback.

Required scopes: `meeting:read-write`, `record_permission:read`.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiV2MeetingsPostRequest
*/
func (a *MeetingsAPIService) V2MeetingsPost(ctx context.Context) ApiV2MeetingsPostRequest {
	return ApiV2MeetingsPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return V2MeetingsPost200Response
func (a *MeetingsAPIService) V2MeetingsPostExecute(r ApiV2MeetingsPostRequest) (*V2MeetingsPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *V2MeetingsPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MeetingsAPIService.V2MeetingsPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/v2/meetings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.v2MeetingsPostRequest == nil {
		return localVarReturnValue, nil, reportError("v2MeetingsPostRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.v2MeetingsPostRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v V2MeetingsPost400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
